# Module1 - Task2 - 课程介绍和类型系统

## 课程概述
* 探讨 JavaScript 自有类型系统的问题，以及借助其他方案解决这些问题
* TypeScript 可以解决 JavaScript 自有类型系统的问题
* TypeScript 大大提高了代码的可靠程度
* 两个主流的类型系统方案
    - TypeScript：基于 JavaScript 基础之上的编程语言
    - Flow：只是一个小工具，弥补了 JavaScript 的不足
* 内容概要
    - 强类型与弱类型
    - 静态类型与动态类型
    - JavaScript 自有类型系统的问题
    - Flow 静态类型检查方案
    - TypeScript 语言规范与基本应用




## 一、类型系统

### 1.1 强类型与弱类型（类型安全）
* 1974 年，美国计算机专家提出
* 强类型语言（Python）
    - 定义：语言层面限制函数的实参类型必须与形参类型相同
    - 强类型有更强的类型约束
    - 强类型语言中，不允许有任意的数据类型隐式转换
* 弱类型语言（JavaScript）
    - 定义：语言层面不会限制实参的类型
    - 弱类型中几乎没有什么约束
    - 弱类型语言中，允许有任意的数据类型隐式转换
* 变量类型允许随时改变的特点，不是强弱类型的差异
* 区别点在于：是否允许有随意的隐式转换类型 
* JavaScript 是弱类型语言
    - 强类型是指在语言语法层面限制不允许传入不同类型，如果传入不同类型的值，在编译阶段就会报出错误，而不是等到运行阶段，通过逻辑判断来限制
    - JavaScript 抛出的类型错误都是在代码层面，运行阶段通过逻辑判断手动抛出的错误



### 1.2 静态类型与动态类型（类型检查）
* 静态类型语言（）
    - 定义：一个变量声明时，它的类型就是明确的；而且变量声明过后，它的类型就不允许再修改
* 动态类型语言（JavaScript）
    - 定义：一个变量在运行阶段才能够明确变量类型；而且变量的类型随时可以改变
    - 在动态类型语言中，变量是没有类型的，变量中存放的值是有类型的
* 区别点在于：变量类型是否允许随时改变


* 强动型：Python、Ruby、Groovy、Erlang、Clojure、Magik
* 强静型：C#、Java、Scala、Haskel、F#
* 弱动型：JavaScript、PHP、VB、Perl
* 弱静型：C、C++


### 1.3 JavaScript 类型系统特征（弱类型且动态类型）
* 几乎没有任何类型限制，是灵活多变的，也确实了类型系统的可靠性
* 为什么JavaScript不是强类型/静类型
    - 早期的 JavaScript 应用简单
    - JavaScript 是一门脚本语言，不需要编译，直接可以在运行环境中运行，没有编译环节，而静态类型语言需要在编译过程中设置类型检查
* 在当时，JavaScript弱类型动态类型是优点；而在现在大规模应用下，这种「优势」变成了短板




### 1.4 弱类型的问题

```
*// JavaScript 弱类型产生的问题

// // 问题示例一：类型问题导致的错误只有在代码运行时才报错 ----------------------------------------------------
// const obj = {};
// obj.foo(); // obj里没有 foo 方法，运行时才会报 TypeError: obj.foo is not a function

// setTimeout(() => {
//     // 此处，只有当这行代码执行的时候，才会报 TypeError，而如果是强类型语言这样写，语法上就会报错，不用等到运行代码才报错；
//     obj.foo();
// }, 5000);



// // 问题示例二： 由于类型问题产生的不同结果 ----------------------------------------------------
// function sum(a, b) {
//     return a + b;
// }
// console.log(sum(100, 100)); // 返回两个参数的和
// console.log(sum(100, '100')); // 返回两个参数的字符串连接



// // 问题示例三： 数据类型随意的隐式转换，对象属性名会自动转换为字符串----------------------------------------------------
const obj = {};
 obj[true] = 100; // 对象属性名会自动转换为字符串
 console.log(obj); // {'true': 100}

```



### 1.5 强类型的优势
* 错误更早暴露
    - 在编码阶段发现类型异常
* 代码更智能，编码更准确
    - 弱类型语言，编辑器不知道变量类型，无法更智能的提示和检查是否错误
* 重构更牢靠
    - 修改了某个公共代码的变量名称，有些编辑器会自动的提示用了这个变量的位置是否需要更改
* 减少代码层面不必要的类型判断
    - 在编码阶段发现类型异常

```
// 强类型的优势

function render(element) {
    // element是个 dom 元素，但是弱类型语言中，编辑器不知道 element 的类型，无法更智能的提示和检查是否出错
    element.className = 'contaniner';
    element.innerHTML = 'hello world';
}


const util = {
    // 此处修改了变量名称 aaa，有些编辑器会自动的提示用了这个变量的位置是否需要更改
    aaa: () => {
        console.log('util func');
    }
}


function sum (a, b) {
    // 如果是强类型语言，不是我们需要的类型，根本传不进来，这个判断也不需要，只是在弱类型语言中才需要
    if (typeof a!== 'number' || typeof b !== 'number') {
        throw new TypeError('arguments must be a number')
    }
    return a + b;
}

```
