# 一、简答题
## 1. 请说出下列最终的执行结果，并解释为什么？

```
var a = [];
for (var i = 0; i < 10; i ++) {
    a[i] = function () {
        console.log(i);
    }
}
a[6]();

```
### 解答
* 执行结果： 10
* 结果解释：当前代码下声明的变量 a 和变量 i，它们是全局变量，在执行`a[6]()`时, for 循环已经结束，a 数组中的元素都是函数，而函数是引用类型，所以数组中的元素本质其实是内存地址，再执行对象的函数时，其实就是将内存地址对应的代码块拿到执行栈中执行，打印变量 i ，但此时的 i 已经是 10，所以输出 10






## 2. 请说出下列最终的执行结果，并解释为什么？

```
var tmp = 123;
if (true) {
    console.log(tmp);
    let tmp;
}

```
### 解答
* 执行结果：控制台报错
* 结果解释：只要块级作用域内存在 let 命令，它所声明的变量就绑定了 这个区域，不再受外界的影响；代码中，块级作用域内有生命了一个局部变量 tmp，绑定了 if 大括号里面的块级作用域，故在 let 声明变量前打印属于未声明先使用，所以会报错；
  * ​	ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。在代码块内，凡是在声明之前就使用这些变量，就会报错；在声明这些变量之前，这些变量都是不可用的；语法上称为 “暂时性死区”。
  * 总之，在使用 let 和 const 命令生米








## 3. 结合 ES6 新语法，用最简单的方式找出数组中的最小值？

```
var arr = [12, 34, 32, 89, 4];

```
### 解答
* 代码如下

```
const min = Math.min(...arr);
console.log(min);  // 4
```

* Math.min(x, y, z...)：接收多个参数，返回给定数值中最小的值；
  * 如果没有参数，结果为 Infinity
  * 如果有任一参数不能被转换为数字，结果为 NaN
* Math.max(x, y, z...)：接收多个参数，返回给定数值中最大的值；
  * 如果没有参数，结果为 Infinity
  * 如果有任一参数不能被转换为数字，结果为 NaN





## 4. 请详细说明 var，let，const 三种声明变量的方式之间的具体差别？
### 解答
* let
    - 在块级作用域内定义的成员，外部无法访问
    - 不能重复声明
    * 暂时性死区，不会出现变量声明提升问题
        - ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。在代码块内，凡是在声明之前就使用这些变量，就会报错；在声明这些变量之前，这些变量都是不可用的
    
     
    
* const（常量声明）
    
    - 在块级作用域内定义的成员，外部无法访问
    * 不能重复声明
    * 暂时性死区，不会出现变量声明提升问题
        - ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭区域。在代码块内，凡是在声明之前就使用这些变量，就会报错；在声明这些变量之前，这些变量都是不可用的
    - 声明变量时就要赋值，不能重复赋值，指的是不允许修改该变量指向的内存地址
    
    
    
* var
    
    - 用 var 声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，或者对于声明在任何函数外的变量来说是全局
    - 有变量提升问题，可以未声明先使用，如果不初始化会输出 undefined，不会报错
    - 可以重复声明，重复赋值  





## 5. 请说出下列最终的执行结果，并解释为什么?

```
var a = 10;
var obj = {
    a: 20,
    fn () {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}
obj.fn();

```
### 解答
* 执行结果：20
* 结果解释：定时器是一个箭头函数，箭头函数不会影响内部的 this 指向，这个箭头函数的 this 指向继承自上一级的执行上下文，定时器的上一级是 fn 函数，fn 是个普通函数，普通函数的 this 指向是谁调用，指向谁，故定时器的 this 指向 obj 对象，因此 this.a = 20；打印结果是 20。







## 6. 简述 Symbol 类型的用途？
### 解答
* 1、为对象创建唯一的属性名，避免对象属性名重复产生的问题
* 2、模拟对象的私有成员，因为 Symbol() 创建的值是唯一的，所以对象内用 Symbol() 创建的私有成员，外部获取不到（此处注意，不能将 Symbol() 赋值给变量，再将此变量设置成对象属性，这种情况下，外部是能够获取到的）
* 是一种基本数据类型 （primitive data type）。Symbol() 函数会返回symbol类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法："new Symbol()"。每个从 Symbol() 返回的symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。在 ES5 中，对象属性名都是字符串容易造成属性名冲突。为了避免这种情况的发生，ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值





## 7. 说说什么是浅拷贝，什么是深拷贝？
### 解答
* 浅拷贝：复制一层对象的属性，并不包括对象里面的为引用类型的数据，当改变拷贝的对象里面的引用类型时，源对象也会改变

* 深拷贝：重新开辟一个内存空间，需要递归拷贝对象里的引用，直到子属性都为基本类型。两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性







## 8. 谈谈你是如何理解 JS 异步编程的，Event Loop 是做什么的，什么是宏任务，什么是微任务？
### 解答

* JS 异步编程：JS 在执行异步任务时，不需要一直等待响应返回了才执行其他任务，而是可以一边等待响应返回一边执行其他任务；

  * 异步（async）是相对于同步（sync）而言的，同步就是一个任务一个任务的执行。只有前一个任务执行完毕，才能执行后一个任务。而异步是不用等待前一个任务执行完成也能够执行。

* Event Loop：即事件循环，是指浏览器或 Node 的一种解决 javaScript 单线程运行时不会阻塞的一种机制，也就是我们经常使用异步的原理。浏览器中的 Event Loop 指的是 Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行；

* 宏任务（MacroTask）：可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行），指 script 全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering；

* 微任务（MicroTask）：可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前task任务后，下一个task之前，在渲染之前，指Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver；

  





## 9. 将下面异步代码使用 Promise 改进？

```
setTimeout(function () {
    var a = "hello";
    setTimeout(function () {
        var b = "lagou";
        setTimeout(function () {
            var c = "I ❤️ U";
            console.log(a + b + c);
        }, 10);
    }, 10);
}, 10);

```
### 解答

* 代码如下
```
// 法一：
function delay(time) {
    const start = new Date();
    while(new Date() - start < time){}
}

const promise = new Promise((resolve, reject) => {
    delay(10);
    resolve('hello');
});
promise.then((value) => {
    delay(10);
    return `${value}lagou`;
}).then((value) => {
    delay(10);
    const result = `${value}I ❤️ U`;
    console.log(result)
}).catch((err) => {
    console.log(err);
});


// 法二：
new Promise((resolve, reject) => {
  setTimeout(() => {
   resolve('hello')
  }, 10);
}).then(v => {
  return new Promise((resolve, reject) => {
     setTimeout(() => {
       resolve(v + ' lagou')
     }, 10);
  })
}).then(v => {
  setTimeout(() => {
   console.log(v + ' I ❤️  U');
  }, 10);
});

```






## 10. 请简述 TypeScript 与 JavaScript 之间的关系？
### 解答
* TypeScript 为 JS 添加了类型，通过在编译阶段进行静态类型检查发现错误，提升开发体验。
* TypeScript 引入了 JS 中没有的接口、枚举、泛型等概念;
* 如果使用 JS 构建大型项目，那随着项目规模变大，特别是在项目重构的时候，很多语法层面的错误，需要在运行时才能被发现；所以在构建大型项目时，TS 比 JS 更有优势
* TypeScript 最终会编译为 JavaScript







## 11. 请谈谈你所认为的 TypeScript 优缺点？
### 解答
* 优点：
    - 功能强大，生态健全完善，任何一种 JavaScript 运行环境都支持，拥有强大的社区，很多 npm 模块都提供了类型声明文件
    - 添加类型注解后，IDE 能够提供更好的代码提示，增加了代码的可读性和可维护性
    - 编译阶段发现错误，特别是在对代码进行重构时，更有把握
    - 编译阶段就能处理类型异常，提高代码的可靠程度和开发效率

* 缺点：
    - 语言本身有很多概念，引入了接口、泛型等概念，有一定学习成本
    - 项目规模较小时，引入 TypeScript 带来的收益成果不明显，可能徒增开发成本
    - 社区中某些类库缺乏声明文件，需要自行编写