# Module2 - Task2 - JavaScript 性能优化

## 性能优化介绍
* 性能优化是不可避免的
* 哪些内容可以看做是性能优化
    - 任何一种可以提高运行效率，降低运行开销的行为都是优化操作
* 本节主讲 JavaScript 性能优化



## 内容概要
* 内存管理
* 垃圾回收与常见的 GC 算法
* V8 引擎的垃圾回收
* Performance 工具
* 代码优化实例




## 1、JavaScript 内存管理
### 1.1 内存为什么需要管理

```
// 产生内存泄漏
function fn () {
    arrList = [];
    arrList[100000] = 'lg is a coder';
}
fn();

```

### 1.2 内存管理介绍
* 内存：由可读写单元组成，不是一片可操作空间
* 管理：人为的去操作一片空间的申请、使用和释放
* 内存管理：开发者主动申请空间、使用空间、释放空间
* 管理流程：申请——使用——释放


### 1.3 JavaScript 中的内存管理
* 由于 ECMAScript 中提供没有相应内存管理的 API，JavaScript 不能像 C/C++ 那样由开发者主动的调用相应的 API 来完成空间的管理
* 可以通过 JS 脚本演示一个空间的生命周期的完成过程
    - 申请内存空间：let obj = {}
    - 使用内存空间：obj.name = 'lanQueen';
    - 释放内存空间：obj = null
    
    ```
        // 申请内存空间
        let obj = {}
        
        // 使用内存空间
        obj.name = 'lanQueen';
        
        // 释放内存空间
        obj = null
    
    ```

## 2、JavaScript 中的垃圾回收

### 2.1 哪些内容会被当做垃圾看待
* 对于前端开发来说，JavaScript 中的内存管理是自动的，每当创建数组、对象、函数时，会自动分配相应的内存空间；
* 原始数据类型的垃圾回收是由程序语言自身控制
* 本节的垃圾回收针对的是当前存储在堆里的对象数据

#### 垃圾回收工作时会阻塞 js 代码的执行，垃圾回收和程序执行不能同时进行

#### 下面两种情况的对象，会被当做垃圾回收
* 当对象不再被引用或不再需要使用时，即生命周期结束的变量，是局部变量
    - 后续代码在执行过程中，通过引用关系无法找到某些对象时
    - 不再需要使用的变量即生命周期结束的变量，是局部变量；
    - 局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用（闭包），改变了就会被标记回收
    - 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收

* 当对象不能从根上访问到时
    - 这些对象其实是存在的，但是由于代码中有些不合适的语法或者结构性的错误，没办法找到这些对象

#### 引用
* 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或显示），叫做一个对象引用另一个对象
    - 一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）
    - 此处的对象不仅指 JS 对象，还包括函数作用域（或者全局词法作用域）

        
#### 可达对象
* 可以访问到的对象就是可达对象（通过具体的引用，或是在当前作用域链查找，只要能找到，就认为是可达的）
    - 可达的标准就是从根触发是否能够被找到  
    - JavaScript 中的根就可以理解为是全局变量对象，即全局执行上下文

    
#### 垃圾回收：找到垃圾，让 js 引擎进行空间的释放和回收

```
// JavaScript 中的引用与可达

/* 

    xm 的对象空间被 obj 对象引用了；
    在全局执行上下文中，obj 对象可以从根上被找到，故 obj 是可达的
    故 xm 的对象空间就是可达的

    let ali = obj;使得 xm 的对象空间多了一次引用，此时 xm 的对象空间有两个引用

    obj = null; 此时 xm 对象空间的引用相当于断掉了，但是因为 ali 还在引用 xm 的对象空间，xm 的对象空间仍然是可达的
*/
let obj = { name: 'xm'}

// xm 的空间多了一次引用
let ali = obj;

obj = null;

```

```
// 可达对象代码示例

function objGroup(obj1, obj2) {
    obj1.next = obj2;
    obj2.prev = obj1;
    return {
        o1: obj1,
        o2: obj2
    }
}

let obj = objGroup({name: 'obj1'}, {name: 'obj2'});

console.log(obj);
/*
{
  o1: { name: 'obj1', next: { name: 'obj2', prev: [Circular] } },
  o2: { name: 'obj2', prev: { name: 'obj1', next: [Circular] } }
}
*/


// 删除所有对 obj1 的引用，则 obj1 就是垃圾，会被 js 引擎进行空间的释放和回收
delete obj.o1;
delete obj.o2.prev;

console.log(obj);
// { o2: { name: 'obj2' } }

```






## 3、GC 算法
### 3.1 GC 的定义与作用
#### 定义
* GC 就是垃圾回收机制的简写

#### 作用
* GC 在工作时可以找到内存中的垃圾，并释放和回收空间


### 3.2 GC 的垃圾有哪些
#### 1）程序中不再被引用的对象（从程序需求的角度考虑，对象不再被引用）
    
    ```
    // 某个数据在使用完成之后，上下文里面不再用到，就可以把它当成垃圾，例如下面代码中的 name
    function func() {
        name = 'lg';
        return `${name} is a coder`;
    }
    
    // 函数调用完成后，从需求的角度看，name 不再需要，可以把它当成垃圾
    func();
    
    ```

#### 2）程序中无法被访问到的对象（从程序运行完成后，变量能否被引用到的角度考虑，对象不能从根上被访问到）
    
    ```
    // name 
    function func() {
        const name = 'lg';
        return `${name} is a coder`;
    }
    // 函数调用完成后，外部作用域外无法访问到变量 name，可以把它当成垃圾
    func();
    
    ```

### 3.3 GC 算法是什么
#### GC 算法是一种机制，由内部的垃圾回收器完成具体的工作
* 垃圾回收器具体的工作内容就是查找垃圾、释放空间、回收空间
* 算法就是垃圾回收器在工作的过程中查找、释放、回收所遵循的规则
#### GC 算法要解决的问题
* 如何查找垃圾
* 如何释放空间
* 回收空间又如何进行分配


### 3.4 常见的 GC 算法
* 引用计数
* 标记清除
* 标记整理
* 分代回收




## 4、常用的 GC 算法介绍

### 4.1 引用计数算法

#### 4.1.1 实现原理
* 引用算法定义“内存不再使用” 的标准很简单，就是看一个对象是否有指向它的引用

* 核心思想：
   - 设置引用数，通过判断当前引用数是否为 0

* 引用计数器
    - 引用计数器的存在导致了引用计数算法和其他算法相比，执行效率有所区别
    - 当引用关系改变时，引用计数器修改对应的引用数字

* 引用计数算法执行过程：
    - 引用计数器设置引用数，判断当前引用数是否为 0
    - 引用关系改变时修改引用数字
    - 引用数字为 0 时立即回收

* 解释：
    - 内部通过引用计数器来维护当前项的引用数，通过判断当前引用数是否为0，来决定是否是垃圾；
    - 当引用关系改变时，引用计数器修改对应的引用数值
    - 当引用数字为 0 时，GC 机制开始工作，将其所在对象空间进行释放和回收再使用



#### 4.1.2 优缺点
* 优点：
    1. 可以即时回收垃圾对象
    
    2. 最大限度减少程序暂停
        + 应用程序执行过程中，必然会消耗内存，内存是有上限的，内存有满的时候，由于引用计数算法时刻监控引用数值为 0 的对象，当内存即将爆满的时候，引用计数会立马找到引用数值为 0 的对象进行释放和回收，保证当前的内存不会有占满的情况产生

* 缺点：
    1. 无法回收循环引用的对象
        + 函数调用结束后，虽然函数内的变量无法从根部被访问，但是由于该算法判断的标准是引用数值是否为 0，obj1 和 obj2 在各自的大括号作用域下，有着相互指引关系，它们的引用数值并不为 0，引用技术算法就无法将它们回收
    
    2. 时间开销大，资源消耗较大
        + 当前的引用计数器需要维护引用数值的变化，要时刻监控当前引用数值是否需要修改，本身修改数值就是需要时间的，又有很多对象需要修改引用数值，引用数值可能很大也可能很小，频繁操作，资源消耗较大，且消耗的时间也更多

```
function fn() {
    const obj1 = {};
    const obj2 = {};
    obj1.name = obj2;
    obj2.name = obj1;
    return 'lg is a coder';
}
fn();
/* 
    fn 执行结束后，
    虽然在全局作用域下，obj1, obj2 不再被引用，引用计数应该是为 0，
    但是 obj1 的 name 指向 obj2, obj2 的 name 指向 obj1, 
    obj1 和 obj2 在各自的大括号作用域下，有着相互指引关系，这种情况下，它们的引用计数值并不为 0，引用技术算法就无法将它们回收
*/

```


### 4.2 标记清除算法

#### 4.2.1 实现原理
* 核心思想：将垃圾回收过程分为两个阶段
    1. 标记阶段
        + 遍历所有对象找到活动对象（相当于可达对象）进行标记操作
    
    2. 清除阶段
        + 遍历所有对象清除没有标记的对象，释放并回收它们的内存空间，并将回收的空间放到空闲链表中，方便后面的程序申请使用；同时清除阶段一中设置的标记，以方便下一次 GC 的工作

* 标记清除算法在遍历过程中，如果遍历查找的可达对象有后代，会采用递归的方式来查找后代中的可达对象进行标记

#### 4.2.2 优缺点
* 优点：
    1. 可以回收循环引用的对象
        + 函数调用结束后，函数内的局部变量失去了和 global 在作用域之间的连接，局部变量无法从根部被访问，此时局部变量就是不可达对象，算法在阶段一时就不会被标记，阶段二就直接被清除了

* 缺点：
    1. 容易产生碎片化空间，浪费空间（不能使空间得到最大化使用）
        + 假设从根部查找到对象 a, a 的左右两侧有两个不可达对象 b(2个字的空间) 和 c(1个字的空间), 则 b、c 会被回收，由于 b、c 被 a 分隔，释放后的 b、c 对象的地址不连续，造成释放的内存被分散的放在空闲链表，新的变量需要的内存一旦和b、c 无法匹配，就会造成释放的空间不能被最大化使用

    2. 不能立即回收垃圾对象
        + 即使在遍历过程中发现不可达对象，也要等到都遍历完再清除，而且清除的时候程序是停止工作的
    
    3. 清除过程中程序会停止工作


### 4.3 标记整理算法

#### 4.3.1 实现原理
* 标记整理算法可以看做是标记清除的增强
* 标记整理算法也分为两个阶段
    1. 标记阶段，和标记清除算法的标记阶段一致
        + 遍历所有对象找到活动对象（相当于可达对象）进行标记操作
    
    2. 清除阶段，在清除之前会先执行整理操作，移动对象位置，让它们在地址上连续，然后再清除

#### 4.3.2 优缺点
* 优点：
    1. 减少碎片化空间，最大化利用释放出来的空间
        + 先整理的好处是：不会出现大批量分散的空间，回收的内存空间基本是连续的，就可以最大化利用释放出来的空间

* 缺点：
    1. 不能立即回收垃圾对象
        + 即使在遍历过程中发现不可达对象，也要等到都遍历完再清除，而且清除的时候程序是停止工作的
    
    2. 清除过程中程序会停止工作





## 5、V8 介绍

### 5.1 认识 V8

#### V8 是一种主流的 JavaScript 执行引擎（Chrome 浏览器和 Node 环境都使用）
#### V8 特点
* 速度快采用即时编译（不需要将源代码转换为字节码）
* 内存设限（64 位：<= 1.5 G | 32 位：<= 800 M）
    - 为了浏览器而产生，对于网页应用足够使用
    - V8 内部的垃圾回收机制决定采用这个内存足够



### 5.2 V8 垃圾回收策略
#### V8 垃圾回收策略
* 采用分代回收的思想
* 把内存空间分为新生代存储区和老生代存储区
* 针对不同对象采用不同算法
    

#### V8 中常用的 GC 算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量
    

### 5.3 V8 内存分配
#### V8 内存空间分为两个一大一小空间
    
* 大空间用于存储老生代对象，属于老生代区域（64位：1.4G | 32位：700M）
    
* 小空间用于存储新生代对象，属于新生代区域（64位：32M | 32位：16M）


### 5.4 V8 如何回收新生代对象
#### 新生代对象说明
* 存储在左侧新生代区域
    
* 新生代对象指的是存活时间较短的对象
   - 局部作用域下的变量，在执行完之后就会被回收

#### 新生代对象回收的实现原理
* 采用空间复制算法 + 标记整理算法    
    
* 新生代内存区分为两个等大的小空间
    
* 使用空间为 From，空闲空间为 To

* 活动对象存储于 From 空间
    - 在 From 空间应用到一定程度之前，To 空间是空闲的，没有使用的
    
* 标记整理后将活动对象拷贝到 To 空间
    - From 空间应用到一定程度之后，会触发 GC 机制
    - GC 机制通过标记整理算法操作 From 空间的活动对象
    -  标记整理完成后，将 From 空间的活动对象拷贝到 To 空间，
    -  拷贝操作相当于备份了 From 空间的活动对象，此时直接释放 From 空间，就完成了垃圾回收
    
* 释放 From 空间，From 与 To 交换空间完成释放
    - 原来的 From 空间变成了空闲空间
    - 原来的 To 空间变成了活动对象的存储空间

#### 新生代对象回收细节说明
* 拷贝过程中可能出现晋升，晋升就是将新生代对象移动至老生代区域
    - 如果发现某个变量对象也出现在老生代对象里（闭包），就将其移入老生代区域

* 判断晋升的两个标准：
    - 一轮 GC 之后还存活的新生代对象需要晋升
    - To 空间的使用率超过 25%，To 空间的活动对象都需要晋升
        + To 空间超过一定限制，转变为活动对象的存储空间后，新进来的对象空间可能就不够用了


### 5.5 V8 如何回收老生代对象
#### 老生代对象说明
* 存储在右侧老生代区域
    
* 老生代对象指的是存活时间较长的对象
    - 全局作用域下的变量，要在程序退出时（浏览器卸载页面）才会被回收
    - 闭包里存放的变量

#### 老生代对象回收的实现原理
* 主要采用标记清除算法 + 标记整理算法 + 增量标记算法   
    
* 首先是要标记清除算法完成垃圾空间的回收（主要针对老生代对象）
    - 虽然产生空间碎片化，但是 V8 底层使用最多的还是标记清除，相对于空间碎片化，速度快更重要
    
* 采用标记整理算法进行空间优化
    - 当有新生代对象需要晋升，老生代区域存储空间不足时，会触发标记整理，对之前的碎片化进行整理回收
    - 当有新生代区域内容要往老生代区域移动，且此时老生代区域剩余存储空间不足以存储移动来的新生代对象时，就会触发标记整理，把之前的碎片空间进行整理回收
    
* 采用增量标记进行效率优化


#### 新/老生代细节对比
* 新生代区域垃圾回收使用空间换时间 
    - 采用空间复制算法，基本上一直会存在空闲空间；
    - 新生代区域本来就比较小，分出来的空间就更小，相对于它所带来的时间上的提升是微不足道的

* 老生代区域垃圾回收不适合复制算法
    - 老生代区域空间较大，一分为二比较浪费空间
    - 老生代存储的数据量大，空间复制耗时

#### 增量标记算法
* 遍历对象进行标记（此处针对的是老生代对象）

* 增量标记，分多次标记
   - 有可能遍历查找到第一层的可达对象后，就停下，让程序执行；一段时间后 GC 继续遍历完成下一轮的标记操作，然后程序再次执行；就这样交替执行，直到标记完成进行垃圾回收操作

#### 增量标记算法优点
1. 实现垃圾回收和程序执行交替工作
2. 提升代码运行效率
    - 将一整段的垃圾回收操作拆分成多个小部分，组合完成垃圾回收，替代之前一次性做完的垃圾回收操作
3. 提升用户体验
    - 最大限度的将长时间的停顿切分成多次更小段的停顿，用户体验更好


### 5.6 V8 总结
* V8 是一款主流的 JavaScript 执行引擎
* V8 内存设置上限
* V8 基于分代回收思想实现垃圾回收
* V8 内存分为新生代和老生代
* V8 垃圾回收常见的 GC 算法







## 6、Performance 介绍

### 6.1 Performance 工具介绍
#### 为什么使用 Performance
* 通过 Performance 工具时刻监控内存对当前程序运行过程中内存变化进行时时监控
    - GC 的目的是为了实现内存空间的良性循环
    - GC 的目的是为了实现内存空间的良性循环
良性循环的基石是内存空间的合理使用
    - GC 的目的是为了实现内存空间的良性循环
时刻关注才能确定内存使用是否合理
    - GC 的目的是为了实现内存空间的良性循环
Performance 提供多种监控方式

#### Performance 使用步骤
1. GC 的目的是为了实现内存空间的良性循环
浏览器地址栏输入目标地址
2. 进入开发人员根据面板，选择性能
3. 开启录制功能，访问具体界面
4. 执行用户行为，一段时间后停止录制
5. 分析界面中记录的内存信息







### 6.2 内存问题的体现
#### 内存问题的外在表现（网络环境正常的情况下）
* 页面出现延迟加载或经常性暂停
    - 底层可能伴随着频繁的垃圾回收
    - 可能是有代码内存瞬间爆满导致垃圾回收频繁操作

* 页面持续性出现糟糕性能
    - 底层可能存在内存膨胀：当前页面为了达到最佳使用速度，申请的内存空间大小远超当前设备本身所能提供的内存大小

* 页面性能随时间延长越来越差
    - 底层可能伴随着内存泄漏，导致使用时间越久，页面流畅度越差

#### 产生内存问题的可能原因
* 频繁垃圾回收
* 内存膨胀
* 内存泄漏




### 6.3 监控内存的几种方式
#### 界定内存问题的标准
* 内存泄漏：内存使用持续升高
    - 通过内存走势的是否持续升高
* 内存膨胀：在多数设备上都存在性能问题
    - 可能是代码问题
    - 也可能是由于当前设备本身的硬件不支持
* 频繁垃圾回收：通过内存变化图进行分析

#### 监控内存的几种方式
* 浏览器任务管理器
* Timeline 时序图记录
* 堆快照查找分离 DOM
* 判断是否存在频繁 GC




### 6.4 任务管理器监控内存
#### 借助浏览器的任务管理器监控内存变化
* 任务管理器简单介绍
    - 内存：原生内存，当前界面里 DOM 节点所占据的内存，如果说这个数值在持续增大，说明此界面在不断创建新 DOM 节点
    - JavaScript 内存：表示 JS 的堆，需要关注小括号里面的内容，表示当前界面正在使用的所有可达对象的内存大小；
        + 如果这个数字一直在正大，说明当前界面在创建新对象或现有对象在不断增长
        + 如果数值一直增加，没有减小，说明内存有问题
* 任务管理器只能帮助我们说明内存是否有问题，无法定位问题




### 6.5 Timeline 记录内存
#### 通过时间线记录内存变化，精确定位问题
* 内存监控
    - JS Heap: JS堆
    - Documents: 文档
    - Nodes: 节点
    - Listeners: 监听器
    - GPU memory: GPU 内存



### 6.6 堆快照查找分离 DOM
#### 堆快照留存 JS 堆照片
* 工作原理：找到 JS 堆，留存 JS 堆照片，通过照片监控所有信息
    - 页面上没有渲染或使用，但是仍然在堆中占据内存
* 类似于分离 DOM 来查找信息
* 什么是分离 DOM
    - 界面元素应该存活在 DOM 树上
        + 
    - 垃圾对象时的 DOM 节点
        + 节点从 DOM 树上脱离，JS 代码中没有被引用
    - 分离状态的 DOM 节点
        + 节点从 DOM 树上脱离，JS 代码中仍然被引用；这种节点页面上是看不到的，但是仍然占用着内存空间；这种情况属于内存泄漏




### 6.7 判断是否存在频繁 GC
#### 为什么要确定频繁的垃圾回收
* GC 工作时应用程序是停止的
* 频繁且过长的 GC 会导致应用假死
* 用户使用中感知应用卡顿

#### 性能工具监测指标
* Timeline中频繁的上升下降
* 任务管理器中数据频繁的增加减小


### 6.8 Performance 总结
* Performance 使用流程
* 内存问题的相关分析
* Performance 时序图监控内存变化
* 任务管理器监控内存变化
* 堆快照查找分离 DOM






## 7、代码优化介绍

#### 如何精准测试 JavaScript 性能
* 本质上就是采集大量的执行样本进行数学统计和分析
* 使用基于 Benchmark.js 的 https://jsperf.com/ 完成

#### Jsperf 使用流程
* 使用 Github 账户登录
* 填写个人信息（非必须）
* 填写详细的测试用例信息（title、slug）
    - slug 必须唯一，生成一个空间访问测试用例
* 填写准备代码 （DOM 操作时经常使用）
* 填写必要有 setup 与 teardown 代码
* 填写测试代码片段

#### Jsperf 测试指标
* Ops/sec：表示每秒钟执行测试代码的次数，数值越大越好。
* ±0.91%：表示测试过程中的统计误差，以及相对最好的慢了多少（%）




## 8、代码优化方式介绍

### 8.1 慎用全局变量
#### 为什么要慎用全局变量
1. 全局变量定义在全局执行上下文，是所有作用域链的顶端
    - 局部向上查找全局变量的时间消耗较大，降低了代码的执行效率
2. 全局执行上下文一直存在于上下文执行栈，知道程序退出才会回收
    - 不利于 GC 机制运行，降低程序运行过程中对于内存的使用
3. 如果某个局部作用域出现了同名变量则会污染或遮蔽全局

#### 使用全局变量和局部变量两种方式实现同样的功能，并在 jsperf 里进行性能测试



### 8.2 缓存全局变量
* 将无法避免的全局变量缓存到局部

```
// 直接使用全局变量 slower
function getBtn() {
    let oBtn1 = document.getElementById('btn1');
    let oBtn3 = document.getElementById('btn3');
    let oBtn5 = document.getElementById('btn5');
    let oBtn7 = document.getElementById('btn7');
    let oBtn9 = document.getElementById('btn9');
}

// 缓存全局变量，性能更快 fatest
function getBtn2() {
    let obj = document;
    let oBtn1 = obj.getElementById('btn1');
    let oBtn3 = obj.getElementById('btn3');
    let oBtn5 = obj.getElementById('btn5');
    let oBtn7 = obj.getElementById('btn7');
    let oBtn9 = obj.getElementById('btn9');
}

```


### 8.3 通过原型对象添加附加方法
* 在原型对象上新增实例对象需要的方法
    - 实例对象和构造函数都可以指向原型对象，构造函数内部具有一个方法让后续的实例对象都可以频繁的调用

```
// 直接在构造函数内部定义方法 slower
var fn1 = function() {
    this.foo = function() {
        console.log(111111);
    }
}
let f1 = new fn1();


// 实例对象和构造函数都可以指向原型对象
// 在原型对象上新增方法 fatest
var fn2 = function() {}
fn2.prototype.foo = function() {
    console.log(111111);
}
let f2 = new fn2();

```


### 8.4 避开闭包陷阱
#### 关于闭包
* 闭包是一种强大的语法
* 闭包使用不当很容易出现内存泄漏
* 不要为了闭包而闭包




### 8.5 避免属性访问方法使用
#### JavaScript 中的面向对象
* JS 不需属性的访问方法，所有属性都是外部可见的
* 使用属性访问方法只会增加一层冲定义，没有访问的控制力

#### 建议采用对象实例直接访问对象成员的属性
```
// slower
// 定义成员属性的访问函数 getAge
function Person() {
    this.name = 'icoder';
    this.age = 18;
    this.getAge = function() {
        return this.age;
    }  
}
const p1 = new Person();
// 通过实例化后对象的访问函数来访问属性
const a = p1.getAge();


// fastest
// 不设置属性访问方法 
function Student() {
    this.name = 'icoder';
    this.age = 18;
}
const p2 = new Student();
// 直接通过实例化后对象的属性名称访问属性
const b = p2.age;

```



### 8.6 For 循环优化

```
// 无优化 速度 second
const arrList1 = [];
arrList1[10000] = 'icoder';
for (let i = 0; i < arrList1.length; i++) {
    console.log(arrList1[i]);
}


// 速度 third
const arrList2 = ['a','b','c'];
arrList2[10000] = 'icoder';
for (let i = arrList2.length; i; i--) {
    console.log(arrList2[i-1]);
}


// 速度 first
const arrList3 = [];
arrList3[10000] = 'icoder';
const length = arrList3.length;
for (let i = 0; i < length; i++) {
    console.log(arrList3[i]);
}


```



### 8.7 选择最优的循环方法
* 循环方式比较：for   for...in  forEach 
* forEach 性能更好
```
// forEach 速度 first
const arrList3 = new Array(1, 2, 3, 4, 5);
arrList3.forEach((item) => {
    console.log(item);
})

// for 速度 second
const arrList1 = new Array(1, 2, 3, 4, 5);
const length = arrList1.length;
for (let i = 0; i < length; i++) {
    console.log(arrList1[i]);
}


// for...in 速度 third
const arrList2 = new Array(1, 2, 3, 4, 5);
for (const key in arrList2) {
    console.log(arrList2[key]);
}

```




### 8.8 文档碎片优化节点添加
* 节点的添加操作必然会有回流和重绘
#### createDocumentFragment()——用来创建虚拟的节点对象，或者说用来创建文档碎片节点，可以包含各种类型节点，在刚开始创建的时候是空的
##### 1. 语法
* let fragment= document.createDocumentFragment();
    - fragment 是一个指向空的 DocumentFragment 对象的引用
##### 2. 描述
* DocumentFragment 是 DOM 节点的，它们不是主 DOM 树的一部分。通常用于创建文档片段，将元素附加到文档片段，然后将文档片段附加到 DOM 树。在 DOM 树中，文档片段被其所有的子元素所替代
* 文档片段存在于内存中，并不在 DOM 树种，将子元素插入到文档时不会引起页面回流（对元素和几何上的计算）

```
// html
<ul id="ul"></ul>

var element  = document.getElementById('ul'); // assuming ul exists
var fragment = document.createDocumentFragment();
var browsers = ['Firefox', 'Chrome', 'Opera', 
    'Safari', 'Internet Explorer'];

browsers.forEach(function(browser) {
    var li = document.createElement('li');
    li.textContent = browser;
    fragment.appendChild(li);
});

element.appendChild(fragment);

```
##### 关于
* DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。最大的区别是因为DocumentFragment不是真实DOM树的一部分，它的变化不会引起DOM树的重新渲染的操作(reflow) ，且不会导致性能等问题
* 可以使用如下方式创建空的 DocumentFragment

```
    let fragment = document.createDocumentFragment();
    
    或
    
    // 这种方式 IE 不支持
    let fragment = new DocumentFragment();
```



```
// 速度 slower
// 直接 appendChild 
for (let i = 0; i < 10; i++) {
    const oP = document.createElement('p');
    oP.innerHTML = i;
    document.body.appendChild(oP);
}


// 速度  fastest 
// 利用文档碎片化优化节点添加操作：createDocumentFragment()
const fragEle = document.createDocumentFragment();
for (let i = 0; i < 10; i++) {
    const oP = document.createElement('p');
    oP.innerHTML = i;
    fragEle.appendChild(oP);
}
document.body.appendChild(fragEle);

```




### 8.9 克隆优化节点操作
* 当需要新增节点时，可以先在页面找到一个与要克隆的节点相似的节点，然后克隆它，再将克隆后的的节点添加到文档中

```
// 速度 slower
// 方式一：直接使用 createElement()，然后appendChild
for (let i = 0; i < 3; i++) {
    const oP = document.createElement('p');
    oP.innerHTML = i;
    document.body.appendChild(oP);
}

// 速度 fastest
// 方式二：找到相似的，先克隆，然后再appendChild
let oldP = document.getElementById('box1');
for (let i = 0; i < 3; i++) {
    // false表示只克隆标签，不克隆内部内容，属于浅克隆
    const newP = oldP.cloneNode(false);
    newP.innerHTML = i;
    document.body.appendChild(newP);
}

```



### 8.10 直接量替换 new Object
* 当定义对象和数组时，使用直接量的形式更快
```
// 速度：faster
// 方式一：直接直接量
var a = [1, 2, 3]

// 速度：slower
// 方式二：先创建一个长度为 3 的数组，然后填数据
var a1 = new Array(3)
a1[0] = 1
a1[1] = 2
a1[2] = 3

```
